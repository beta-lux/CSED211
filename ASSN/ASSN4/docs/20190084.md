Cache Lab: Understanding Cache Memories
===
20190084 권민재, CSED211



# Part A: Writing a Cache Simulator
## 개요

* 이 프로그램은 $s$ (Number of set index bits), $E$ (number of lines per set), $b$ (Number of block bits), $t$ (파일 이름)를 입력으로 받는다. 이 중 특히 $t$ 같은 경우는, valgrind trace가 담긴 파일의 파일 이름이다.
* 이 프로그램은 이 입력에 따라 캐시를 시뮬레이션 하고, 그 결과로 hit, miss, eviction의 횟수를 출력한다.



## 구조
### 자료 구조

#### Cache

```c
typedef struct {
    int numSet;
    int numLine;
    Set *setList;
} Cache;
```

 `Cache` 는 메인 캐시를 표현하기 위한 구조체로,  `numSet`, `numLine`, `arrSet` 으로 구성된다.

* `numSet` 은 캐시의 set 개수로,  $2^s$가 저장된다. 
* `numLine` 은 set 마다의 line 개수로, $E$가 저장된다.
* `setList` 는 `Set` 자료형의 포인터로, `numSet` 개의 set들이 동적할당 된 배열을 가리킨다.



#### Set

```c
typedef struct {
    Block *blockList;
} Set;
```

`Set` 은 캐시의 set을 표현하기 위한 구조체로, `blockList`로 구성된다.

* `blockList` 는 각 set 에 존재하는  `block` 배열이며, $E$ 개의 block들이 동적할당 된 배열을 가리킨다.



#### Block

```c
typedef struct {
    int valid;
    unsigned long long tag;
    int lruCount;
} Block;
```

`Block` 은 캐시의 block을 표현하기 위한 구조체로, `valid`,`tag`, `lruCount` 로 구성된다.

* `valid`는 이 블럭이 유효한지 그 여부를 나타낸다.
* `tag`는 블럭의 tag를 나타낸다.
* `lruCount` 는 LRU 기반의 캐시를 구현하기 위해, 각 블럭 별로 지정되는 LRU 값, 즉 일종의 타임스탬프로서 작용한다.



#### 자주 사용되는 변수

```c
Cache cache = {};
int s = 0, E = 0, b = 0;
int LRU = 0;
int hits = 0, misses = 0, evictions = 0;
```

* `cache`는 이 프로그램에서 시뮬레이션 할 캐시를 의미한다.
* `s`, `E`, `b`에는 이 프로그램의 인자로 들어온 $s$, $E$, $b$ 가 저장된다.
* `LRU` 는 LRU 로 캐시를 구현하기 위한 전역 LRU 카운터이다.
* `hits`, `misses`, `evictions`는 hit, miss, eviction의 횟수로, 이 프로그램의 결과값이 담긴다.





### 알고리즘

#### 1. Parse Input

 우선 프로그램이 실행되면, `getopt`를 이용하여 인자로 들어온 $s$, $E$, $b$, $t$를 저장한다. 만약, 인자가 하나라도 없다면 1을 반환하며 프로그램을 종료한다. 그리고, t를 파일 이름으로 해서 파일을 여는데 실패했다면, 1을 반환하면서 프로그램을 종료한다. 



#### 2. Init Cache 

##### initCache()

캐시를 초기화 하는데에는 함수 `initCache`가 이용된다. 이 함수에서는 캐시의 `numSet`에 $2^s$, `numLine`에 $E$를 저장하고, `setList`에 `numSet` 개의 set으로 구성된 배열을 동적할당 한다. 그리고, `setList`의 각 set에 대해 `numLine` 개의 block으로 구성된 배열을 동적할당 한다. 각 block들의 `valid`, `tag`, `lruCount`는 0으로 초기화 된다.



#### 3. Simulate Cache

##### simulate(FILE* file)

 캐시를 시뮬레이션 하는데 있어서 우선 이 함수가 불리게 된다. 이 함수는 `file`을 한 줄 씩 읽으면서 경우에 따라 `cacheAccess`를 호출하여 캐시에 액세스하는 행위를 시뮬레이션 한다. 우리는 valgrind trace의 operation으로 I, L, S, M을 입력받는데, 이 중 **I 가 입력되었을 때에는** 캐시에 액세스할 필요가 없으므로, 무시하고, **나머지 경우에 대해서는** 우선 기본적으로 1번 캐시 액세스를 진행한다. 하지만, 이 중에서도 **M 의 경우에는** 데이터를 수정한 경우이므로, 캐시에 1번 더 액세스를 해야한다. 즉, 요약하면 이 함수에서는 파일을 한 줄 씩 읽으면서 인스트럭션을 해석하는데, 이때 `cacheAcess`는 **I일 때 0번, L이나 S 일때 1번, M일 때 2번** 호출된다.

##### cacheAccess(unsigned long long addr)

 이 함수는 어떤 주소를 가지고 캐시에 액세스하는 행위를 시뮬레이션 한다. 우선, 그를 위해서 `addr` 로부터 인덱스와 태그를 구해내고, eviction을 수행할 기준이 되는 LRU `evictionLru`를 충분히 큰 값으로 설정한다. `addr`의 인덱스는 `addr`를 `b` 만큼 오른쪽으로 밀고, 그 값을 $2^s-1$과 $\mathrm{AND}$ 함으로써 구할 수 있다. 또한, `addr`의 태그는 `addr`을 $s+b$ 만큼 오른쪽으로 shift해서 구할 수 있다. 이제  `addr`의 인덱스를 이용해 캐시의 `setList` 중에서 접근할 `set`을 결정하고, 해당 set의 모든 block에 대해 탐색을 수행하면서, 해당 블록이 `valid`하고 `addr`의 태그와 같다면 hit가 발생했음을 기록한다.

 block들에 대해 탐색이 종료된 후, 해당 탐색에서 hit가 발생했다면, `hits` 를 1 증가시키고, hit가 발생한 블럭의 `lruCount`에 전역 LRU 카운터 `LRU` 를 할당한다. 

 만약, hit가 발생하지 않았다면, miss가 발생했다는 뜻이므로, 우선 `misses`를 1 증가시킨다. 이후, set의 블럭들 중에서 `lruCount`가 가장 작은 블럭을 찾는다. 만약, 이 블럭이 `valid` 하다면, eviction이 일어나야 하므로 `evictions`를 1 증가시킨다. 이후, 해당 블럭의 `valid`를 1, 태그를 현재 `addr` 의 태그, 그리고 `lruCount`를 현재 전역 LRU 카운터 `LRU`로 설정한다.

 마지막으로, 전역 LRU 카운터 `LRU`를 1 증가시키고 함수를 종료한다.



#### 4. Finalize

 앞서 **Simulate Cache** 과정을 거치면서 캐시를 시뮬레이션 하는데 있어서 hit, miss, eviction의 횟수를 모두 구했으므로, `printSummary ` 함수를 이용해서 `hits`, `misses`, `evictions`를 출력하고 파일을 닫는다. 또한, `freeCache` 함수 또한 호출하여 할당된 메모리를 정리한다.

##### freeCache()

 이 함수에서는 앞서 `initCache`에서 캐시의 시뮬레이션을 위해 동적 할당한 메모리를 해제한다. 그래서 우선 각 `setList`의 `Block`들을 할당 해제 하고, 이후 `setList`를 할당 해제하여 동적 할당한 모든 메모리를 정리한다.

 

## 토론 및 개선

* 이 코드에서는 구조체를 이용하여 캐시를 구현했는데, 구조체를 이용하여 캐시를 구현하고 나니, 2차원 배열으로도 충분히 이 가상 캐시를 구현할 수 있다는 것을 알았다. 이후, 2차원 배열으로도 캐시를 구현해보고자 한다.
* 이 과제에서는 **전역변수에 대해 제한을 두지 않고 있어서**, 전역변수들을 이용하여 문제를 해결하고 있는데, 이 전역변수들의 사용을 줄일 필요성이 있다.



# Part B: Optimizing Matrix Transpose
## 개요
## 구조
### 자료 구조
### 알고리즘
## 토론 및 개선
