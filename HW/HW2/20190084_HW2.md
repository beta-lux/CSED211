CSED211 Homework 2
===

20190084 권민재

# 1. 
# 2. Exercise 3.60
Consider the following assembly code:
```asm
loop:
    movl %esi, %ecx
    movl $1, %edx
    movl $0, %eax
    jmp .L2
.L3:
    movq %rdi, %r8
    andq %rdx, %r8
    orq %r8, %rax
    salq %cl, %rdx
.L2:
    testq %rdx, %rdx
    jne .L3
    rep; ret
```
The preceding code was generated by compiling C code that had the following overall form:
```c
long loop(long x, long n){
    long result = ____;
    long mask;
    for (mask = ____; mask ____; mask = ____) {
        result |= ____;
    }
    return result;
}
```
Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register %rax. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables.
## A. Which registers hold program values x, n, result, and mask?
* `x`: `rdi`
  * x64 calling convention에 따라, 첫번재 인자인 x는 rdi를 통해 전달받는다.
* `n`: `rsi`
  * x64 calling convention에 따라, 두번째 인자인 n은 rsi를 통해 전달받는다.
* `result`: `rax`
  * `result`는 반환되는 변수인데, 이는 주로 eax를 통해 전달한다.
* `mask`: `rdx`
  * `L3`에서 지속적으로 rdx를 비교한다는 점에서, rdx를 mask라고 추론할 수 있다.

## B. What are the initial values of result and mask?
* `result`: `0`
  * `movl $0, %eax`
* `mask`: `1`
  * `movl $1, %edx`

## C. What is the test condition for mask?
* `mask != 0`
  * `testq %rdx, %rdx`, `jne .L3`에서, rdx가 0이 아닐때 L3으로 점프하므로, 위와 같은 답을 생각할 수 있다.
    
## D. How does mask get updated?
* `mask = mask << n`
  * n은 `movl %esi, %ecx`에 의해 ecx에 그 값이 저장되는데, `salq %cl, %rdx`에서 이 값을 이용하여 마스크를 왼쪽으로 쉬프트하고 있다.
 
## E. How does result get updated?
* `result |= (x & mask)`
  * `movq %rdi, %r8`에서, x의 값이 임시로 r8에 저장되고, r8에 있는 값은 `orq %rdx, %r8`에 의해 mask와 and 연산을 당하게 된다. 이 값이 `orq %r8, %rax`에 의해 `result`에 or 연산이 된 후 담기므로, `result |= (x & mask)`와 같이 업데이트 된다고 말할 수 있다.

## F. Fill in all the missing parts of the C code.
```c
long loop(long x, long n){
    long result = 0;
    long mask;
    for (mask = 1; mask != 0; mask = << n) {
        result |= (x & mask);
    }
    return result;
}
```
# 3. Exercise 3.63
This problem will give you a chance to reverse engineer a switch statement from disassembled machine code. In the following procedure, the body of the switch statement has been omitted:
```c
long switch_prob(long x, long n){
    long result = x;
    switch(n){
        /* Fill in code here */
    }
    return result;
}
```

Figure 3.53 shows the disassembled machine code for the procedure.
The jump table resides in a different area of memory. We can see from the indirect jump on line 5 that the jump table begins at address 0x4006f8. Using the gdb debugger, we can examine the six 8-byte words of memory comprising the jump table with the command x/6gx 0x4006f8. Gdb prints the following:
```gdb
(gdb) x/6gx 0x4006f8
0x4006f8: 0x00000000004005a1 0x00000000004005c3
0x400708: 0x00000000004005a1 0x00000000004005aa
0x400718: 0x00000000004005b2 0x00000000004005bf
```
Fill in the body of the switch statement with C code that will have the same behavior as the machine code.
```c
0000000000400590 <switch_prob>:
400590: 48 83 ee 3c             sub    $0x3c,%rsi
400594: 48 83 fe 05             cmp    $0x5,%rsi
400598: 77 29                   ja     4005c3 <switch_prob+0x33>
40059a: ff 24 f5 f8 06 40 00    jmpq   *0x4006f8(,%rsi,8)
4005a1: 48 8d 04 fd 00 00 00    lea    0x0(,%rdi,8),%rax
4005a8: 00
4005a9: c3                      retq
4005aa: 48 89 f8                mov    %rdi,%rax
4005ad: 48 c1 f8 03             sar    $0x3,%rax
4005b1: c3                      retq
4005b2: 48 89 f8                mov    %rdi,%rax
4005b5: 48 c1 e0 04             shl    $0x4,%rax
4005b9: 48 29 f8                sub    %rdi,%rax
4005bc: 48 89 c7                mov    %rax,%rdi
4005bf: 48 0f af ff             imul   %rdi,%rdi
4005c3: 48 8d 47 4b             lea    0x4b(%rdi),%rax
4005c7: c3                      retq
```

## Answer
```c
long switch_prob(long x, long n){
    long result = x;
    switch(n){
        case 60:
        case 62:
            // 4005a1
            result = x * 8;
            break;
        case 63:
            // 4005aa
            result = (x >> 3);
            break;
        case 64:
            // 4005b2
            result = (x << 4) - x;
            // Here, no break!
        case 65:
            // 4005bf
            x = x * x;
            // Here, no break!
        default:
            // 4005c3
            result = x + 0x4b;
    }
    return result;
}
```
# 4. Exercise 3.64

# 5. Exercise 3.67
# 6. Exercise 3.68
# 7. Exercise 3.70