CSED211 Homework 2
===

20190084 권민재

# 1. 
Read carefully section 3.6.6 and answer the following questions
## A. Why is the conditional move instruction advantageous?
Conditional move를 이용하면 분기를 이용하지 않고도 조건에 따라 값을 달리해야 하는 작업을 수행할 수 있다. '분기'를 이용하지 않는다는 것은 컴퓨터에 있어서 큰 장점인데, 분기 예측에 실패했을 때의 손해를 감수하지 않아도 되며, CPU의 파이프라인에 더 많은 명령어를 넣을 수 있기 때문이다.
## B. As an invalid use of conditional move instruction, it has shown an example of the following code (page 254, 3nd ed.)
```c
long cread(long *xp){
    return (xp ? *xp : 0);
} // if xp is not null pointer, then return the value by dereferencing
// if a compiler generates an assembly code like below, it may make a problem during runtime. (Definitely, gcc compiler will not generate an assembly code like below.)
```
```asm
cread:
    movq (%rdi), %rax
    testq %rdi, %rdi
    movl $0, %edx
    cmove %rdx, %rax
    ret
```
Explain what is wrong in this example.

## Answer
 위와 같은 어셈블리 코드가 생성되었을 때, `rdi`의 값이 무엇이든지 상관 없이 `testq %rdi, %rdi`를 하기 전에 참조되는 것을 알 수 있다. 그렇기 때문에 `rdi`에 잘못된 메모리 주소가 있다면, `rdi`를 참조하는 과정에서 segmentation fault가 발생하는 문제가 예시에 존재한다.
# 2. Exercise 3.60
Consider the following assembly code:
```asm
loop:
    movl %esi, %ecx
    movl $1, %edx
    movl $0, %eax
    jmp .L2
.L3:
    movq %rdi, %r8
    andq %rdx, %r8
    orq %r8, %rax
    salq %cl, %rdx
.L2:
    testq %rdx, %rdx
    jne .L3
    rep; ret
```
The preceding code was generated by compiling C code that had the following overall form:
```c
long loop(long x, long n){
    long result = ____;
    long mask;
    for (mask = ____; mask ____; mask = ____) {
        result |= ____;
    }
    return result;
}
```
Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register %rax. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables.
## A. Which registers hold program values x, n, result, and mask?
* `x`: `rdi`
  * x64 calling convention에 따라, 첫번재 인자인 x는 rdi를 통해 전달받는다.
* `n`: `rsi`
  * x64 calling convention에 따라, 두번째 인자인 n은 rsi를 통해 전달받는다.
* `result`: `rax`
  * `result`는 반환되는 변수인데, 이는 주로 eax를 통해 전달한다.
* `mask`: `rdx`
  * `L3`에서 지속적으로 rdx를 비교한다는 점에서, rdx를 mask라고 추론할 수 있다.

## B. What are the initial values of result and mask?
* `result`: `0`
  * `movl $0, %eax`
* `mask`: `1`
  * `movl $1, %edx`

## C. What is the test condition for mask?
* `mask != 0`
  * `testq %rdx, %rdx`, `jne .L3`에서, rdx가 0이 아닐때 L3으로 점프하므로, 위와 같은 답을 생각할 수 있다.
    
## D. How does mask get updated?
* `mask = mask << n`
  * n은 `movl %esi, %ecx`에 의해 ecx에 그 값이 저장되는데, `salq %cl, %rdx`에서 이 값을 이용하여 마스크를 왼쪽으로 쉬프트하고 있다.

## E. How does result get updated?
* `result |= (x & mask)`
  * `movq %rdi, %r8`에서, x의 값이 임시로 r8에 저장되고, r8에 있는 값은 `orq %rdx, %r8`에 의해 mask와 and 연산을 당하게 된다. 이 값이 `orq %r8, %rax`에 의해 `result`에 or 연산이 된 후 담기므로, `result |= (x & mask)`와 같이 업데이트 된다고 말할 수 있다.

## F. Fill in all the missing parts of the C code.
```c
long loop(long x, long n){
    long result = 0;
    long mask;
    for (mask = 1; mask != 0; mask = (mask << n)) {
        result |= (x & mask);
    }
    return result;
}
```
# 3. Exercise 3.63
This problem will give you a chance to reverse engineer a switch statement from disassembled machine code. In the following procedure, the body of the switch statement has been omitted:
```c
long switch_prob(long x, long n){
    long result = x;
    switch(n){
        /* Fill in code here */
    }
    return result;
}
```

Figure 3.53 shows the disassembled machine code for the procedure.
The jump table resides in a different area of memory. We can see from the indirect jump on line 5 that the jump table begins at address 0x4006f8. Using the gdb debugger, we can examine the six 8-byte words of memory comprising the jump table with the command x/6gx 0x4006f8. Gdb prints the following:
```gdb
(gdb) x/6gx 0x4006f8
0x4006f8: 0x00000000004005a1 0x00000000004005c3
0x400708: 0x00000000004005a1 0x00000000004005aa
0x400718: 0x00000000004005b2 0x00000000004005bf
```
Fill in the body of the switch statement with C code that will have the same behavior as the machine code.
```c
0000000000400590 <switch_prob>:
400590: 48 83 ee 3c             sub    $0x3c,%rsi
400594: 48 83 fe 05             cmp    $0x5,%rsi
400598: 77 29                   ja     4005c3 <switch_prob+0x33>
40059a: ff 24 f5 f8 06 40 00    jmpq   *0x4006f8(,%rsi,8)
4005a1: 48 8d 04 fd 00 00 00    lea    0x0(,%rdi,8),%rax
4005a8: 00
4005a9: c3                      retq
4005aa: 48 89 f8                mov    %rdi,%rax
4005ad: 48 c1 f8 03             sar    $0x3,%rax
4005b1: c3                      retq
4005b2: 48 89 f8                mov    %rdi,%rax
4005b5: 48 c1 e0 04             shl    $0x4,%rax
4005b9: 48 29 f8                sub    %rdi,%rax
4005bc: 48 89 c7                mov    %rax,%rdi
4005bf: 48 0f af ff             imul   %rdi,%rdi
4005c3: 48 8d 47 4b             lea    0x4b(%rdi),%rax
4005c7: c3                      retq
```

## Answer
```c
long switch_prob(long x, long n){
    long result = x;
    switch(n){
        case 60:
        case 62:
            // 4005a1
            result = x * 8;
            break;
        case 63:
            // 4005aa
            result = (x >> 3);
            break;
        case 64:
            // 4005b2
            result = (x << 4) - x;
            x = result;
            // Here, no break!
        case 65:
            // 4005bf
            x = x * x;
            // Here, no break!
        default:
            // 4005c3
            result = x + 0x4b;
    }
    return result;
}
```
# 4. Exercise 3.64
Consider the following source code, where R, S, and T are constants declared with #define:
```c
long A[R][S][T];

long store_ele(long i, long j, long k, long *dest){
    *dest = A[i][j][k];
    return sizeof(A);
}
```
In compiling this program, gcc generates the following assembly code:
```asm
store_ele:
  leaq (%rsi,%rsi,2), %rax
  leaq (%rsi,%rax,4), %rax
  movq %rdi, %rsi
  salq $6, %rsi
  addq %rsi, %rdi
  addq %rax, %rdi
  addq %rdi, %rdx
  movq A(,%rdx,8), %rax
  movq %rax, (%rcx) 
  movl $3640, %eax
  ret 
```

## A. Extend Equation3.1 from two dimensions to three to provide a formula for the location of array element $A[i][j][k]$.
* $\&A[i][j][k] = x_A + 8 * (T * (i * S + j) + k)$
## B. Use your reverse engineering skills to determine the values of R, S, and T based on the assembly code.
### Solution
```asm
store_ele:
  leaq (%rsi,%rsi,2), %rax ; rax = 3rsi
  leaq (%rsi,%rax,4), %rax ; rax = 13rsi
  movq %rdi, %rsi  ; rsi = rdi
  salq $6, %rsi  ; rsi = rdi << 6
  addq %rsi, %rdi ; rdi = rdi + rdi << 6
  addq %rax, %rdi ; rdi = 13rsi + rdi + rdi << 6
  addq %rdi, %rdx ; rdx = rdx + 13rsi + rdi + rdi << 6
  movq A(,%rdx,8), %rax ; rax = A + (rdx + 13rsi + rdi + rdi << 6) * 8
  movq %rax, (%rcx) 
  movl $3640, %eax
  ret 
```
`rax = A + (rdx + 13rsi + rdi + rdi << 6) * 8`

$$A + (k + 13j + i + i \times 2^6) \times 8$$

$$A + 8 \times ((65i + 13j) +k)$$

$$A + 8 \times (13 \times (5i + j) +k)$$

$$R \times S \times T = 3640 \div 8$$

### Answer
`S`: $5$
`T`: $13$
`R`: $(3640 \div 8) \div (5 \times 13) = 7$

# 5. Exercise 3.67
For this exercise, we will examine the code generated by gcc for functions that have structures as arguments and return values, and from this see how these language features are typically implemented.
The following C code has a function process having structures as argument and return values, and a function eval that calls process:
```c
typedef struct {
    long a[2];
    long *p;
} strA;

typedef struct {
    long u[2];
    long q;
} strB;

strB process(strA s){
    strB r;
    r.u[0] = s.a[1];
    r.u[1] = s.a[0];
    r.q = *s.p;
    return r;
}

long eval(long x, long y, long z) {
    strA s;
    s.a[0] = x;
    s.a[1] = y;
    s.p = &z;
    strB r = process(s);
    return r.u[0] + r.u[1] + r.q;
}
```

Gcc generates the following code for these two functions:

```asm
process:
  movq    %rdi,     %rax
  movq 24(%rsp),    %rdx
  movq   (%rdx),    %rdx
  movq 16(%rsp),    %rcx
  movq    %rcx,    (%rdi)
  movq  8(%rsp),    %rcx
  movq    %rcx,   8(%rdi)
  movq    %rdx,  16(%rdi)
  ret
```
```asm
eval:
  subq    $104,     %rsp
  movq    %rdx,  24(%rsp)
  leaq 24(%rsp),    %rax
  movq    %rdi,    (%rsp)
  movq    %rsi,   8(%rsp)
  movq    %rax,  16(%rsp)
  leaq 64(%rsp),    %rdi
  call process
  movq 72(%rsp),    %rax
  addq 64(%rsp),    %rax
  addq 80(%rsp),    %rax
  addq     $104,    %rsp
  ret
```
## A. We can see on line 2 of function eval that it allocates 104 bytes on the stack. Diagram the stack frame for eval, showing the values that it stores on the stack prior to calling process.
|addr.|variable|
|--:|:--|
|<+104>||
|<+96>||
|<+88>||
|<+80>||
|<+72>||
|rdi --> <+64>||
|<+56>||
|<+48>||
|<+40>||
|<+32>||
|<+24>|z|
|<+16>|s.p|
|<+8>|s.a[1]|
|rsp --> <+0>|s.a[0]|
## B. What value does eval pass in its call to process?
* rsp + 64
  * It can be checked out from `leaq 64(%rsp),    %rdi`

## C. How does the code for process access the elements of structure argument s?
* `process` access the elements of structure by `rsp` and offset.
## D. How does the code for process set the fields of result structure r?
* `process` set the fields of result by `rdi` and offset.
## E. Complete your diagram of the stack frame for eval, showing how eval accesses the elements of structure r following the return from process.
|addr.|variable|
|--:|:--|
|<+104>||
|<+96>||
|<+88>||
|<+80>|r.q|
|<+72>|r.u[1]|
|rdi --> <+64>|r.u[0]|
|<+56>||
|<+48>||
|<+40>||
|<+32>||
|<+24>|z|
|<+16>|s.p|
|<+8>|s.a[1]|
|rsp --> <+0>|s.a[0]|
* eval access `r` via `rsp`.
## F. What general principles can you discern about how structure values are passed as function arguments and how they are returned as function results?
* Caller function makes space for structure and passes address to callee function and callee function returns passed address from caller function, because size of structure is bigger than general register. It's how to structure values are passed as function arguments and how they are returned as function results. 
# 6. Exercise 3.68
In the following code, A and B are constants defined with `#define`:
```c
typedef struct {
    int x[A][B]; /* Unknown constants A and B */
    long y;
} str1;
typedef struct {
    char array[B];
    int t;
    short s[A];
    long u;
} str2;
void setVal(str1 *p, str2 *q) {
    long v1 = q->t;
    long v2 = q->u;
    p->y = v1+v2;
}
```
Gcc generates the following code for `setVal`:
```asm
setVal:
    movslq   8(%rsi),    %rax
    addq    32(%rsi),    %rax
    movq       %rax, 184(%rdi)
    ret
```
What are the values of A and B? (The solution is unique.)
## Solution
### q `rsi`
|addr.|variable|size|
|--:|:--|---|
|<+32>|`q->u`|8byte|
|<+12>|`q->s[A]`|14 ~ 20 byte|
|<+8>|`q->t`|4byte|
|rsi --> <+0>|`q->array[B]`|5 ~ 8byte|
`A`는 `7 <= A <= 10`, `B`는 `4 < B <= 8`를 만족해야 한다.

### p `rdi`
|addr.|variable|size|
|--:|:--|---|
|<+184>|`y`|8byte|
|rdi --> <+0>|`p->x[A][B]`|180 ~ 184byte|
`A*B`가 `45 <= A*B <= 46`를 만족해야 한다.

위 두 조건을 만족하는 `A`와 `B`는 아래 답 밖에 존재하지 않는다.

## Answer
`A`: 9, `B`: 5


# 7. Exercise 3.70
Consider the following union declaration:
```c
union ele {
    struct {
        long *p;
        long y;
    } e1;
    struct {
        long x;
        union ele *next;
    } e2;
};
```

This declaration illustrates that structures can be embedded within unions.
The following function (with some expressions omitted) operates on a linked
list having these unions as list elements:

```c
void proc (union ele *up) {
    up-> ____ = *(____) - ____;
}
```

## A. What are the offsets (in bytes) of the following fields:
|variable|offsets (bytes)|
|:--:|--:|
|`e1.p`|0|
|`e1.y`|8|
|`e2.x`|0|
|`e2.next`|8|

## B. How many total bytes does the structure require?
16 bytes

## C.
The compiler generates the following assembly code for proc:
```asm
proc:
    movq 8(%rdi), %rax
    movq  (%rax), %rdx
    movq  (%rdx), %rdx
    subq 8(%rax), %rdx
    movq   %rdx, (%rdi)
    ret
```
On the basis of this information, fill in the missing expressions in the code for proc. Hint: Some union references can have ambiguous interpretations. These ambiguities get resolved as you see where the references lead. There is only one answer that does not perform any casting and does not violate any type constraints.

### Solution
```asm
proc:
    movq 8(%rdi), %rax # rax: *(rdi + 8).
    movq  (%rax), %rdx # rdx: *(rdi + 8)
    movq  (%rdx), %rdx # rdx: *(*(rdi + 8))
    subq 8(%rax), %rdx # rdx: *(*(rdi + 8)) - *(*(rdi + 8) + 8)
    movq   %rdx, (%rdi) # rdi: *(*(rdi + 8)) - *(*(rdi + 8) + 8)
    ret
```

### Answer

```c
void proc (union ele *up) {
    up-> e2.x = *(up->e2.next->e1.p) - up->e2.next->e1.y;
}
```