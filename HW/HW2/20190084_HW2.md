CSED211 Homework 2
===

20190084 권민재

# 1. 
# 2. Exercise 3.60
Consider the following assembly code:
```asm
loop:
    movl %esi, %ecx
    movl $1, %edx
    movl $0, %eax
    jmp .L2
.L3:
    movq %rdi, %r8
    andq %rdx, %r8
    orq %r8, %rax
    salq %cl, %rdx
.L2:
    testq %rdx, %rdx
    jne .L3
    rep; ret
```
The preceding code was generated by compiling C code that had the following overall form:
```c
long loop(long x, long n){
    long result = ____;
    long mask;
    for (mask = ____; mask ____; mask = ____) {
        result |= ____;
    }
    return result;
}
```
Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register %rax. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables.
## A. Which registers hold program values x, n, result, and mask?
* `x`: `rdi`
  * x64 calling convention에 따라, 첫번재 인자인 x는 rdi를 통해 전달받는다.
* `n`: `rsi`
  * x64 calling convention에 따라, 두번째 인자인 n은 rsi를 통해 전달받는다.
* `result`: `rax`
  * `result`는 반환되는 변수인데, 이는 주로 eax를 통해 전달한다.
* `mask`: `rdx`
  * `L3`에서 지속적으로 rdx를 비교한다는 점에서, rdx를 mask라고 추론할 수 있다.

## B. What are the initial values of result and mask?
* `result`: `0`
  * `movl $0, %eax`
* `mask`: `1`
  * `movl $1, %edx`

## C. What is the test condition for mask?
* `mask != 0`
  * `testq %rdx, %rdx`, `jne .L3`에서, rdx가 0이 아닐때 L3으로 점프하므로, 위와 같은 답을 생각할 수 있다.
    
## D. How does mask get updated?
* `mask = mask << n`
  * n은 `movl %esi, %ecx`에 의해 ecx에 그 값이 저장되는데, `salq %cl, %rdx`에서 이 값을 이용하여 마스크를 왼쪽으로 쉬프트하고 있다.
 
## E. How does result get updated?
* `result |= (x & mask)`
  * `movq %rdi, %r8`에서, x의 값이 임시로 r8에 저장되고, r8에 있는 값은 `orq %rdx, %r8`에 의해 mask와 and 연산을 당하게 된다. 이 값이 `orq %r8, %rax`에 의해 `result`에 or 연산이 된 후 담기므로, `result |= (x & mask)`와 같이 업데이트 된다고 말할 수 있다.

## F. Fill in all the missing parts of the C code.
```c
long loop(long x, long n){
    long result = 0;
    long mask;
    for (mask = 1; mask != 0; mask = << n) {
        result |= (x & mask);
    }
    return result;
}
```
# 3. Exercise 3.63
This problem will give you a chance to reverse engineer a switch statement from disassembled machine code. In the following procedure, the body of the switch statement has been omitted:
```c
long switch_prob(long x, long n){
    long result = x;
    switch(n){
        /* Fill in code here */
    }
    return result;
}
```

Figure 3.53 shows the disassembled machine code for the procedure.
The jump table resides in a different area of memory. We can see from the indirect jump on line 5 that the jump table begins at address 0x4006f8. Using the gdb debugger, we can examine the six 8-byte words of memory comprising the jump table with the command x/6gx 0x4006f8. Gdb prints the following:
```gdb
(gdb) x/6gx 0x4006f8
0x4006f8: 0x00000000004005a1 0x00000000004005c3
0x400708: 0x00000000004005a1 0x00000000004005aa
0x400718: 0x00000000004005b2 0x00000000004005bf
```
Fill in the body of the switch statement with C code that will have the same behavior as the machine code.
```c
0000000000400590 <switch_prob>:
400590: 48 83 ee 3c             sub    $0x3c,%rsi
400594: 48 83 fe 05             cmp    $0x5,%rsi
400598: 77 29                   ja     4005c3 <switch_prob+0x33>
40059a: ff 24 f5 f8 06 40 00    jmpq   *0x4006f8(,%rsi,8)
4005a1: 48 8d 04 fd 00 00 00    lea    0x0(,%rdi,8),%rax
4005a8: 00
4005a9: c3                      retq
4005aa: 48 89 f8                mov    %rdi,%rax
4005ad: 48 c1 f8 03             sar    $0x3,%rax
4005b1: c3                      retq
4005b2: 48 89 f8                mov    %rdi,%rax
4005b5: 48 c1 e0 04             shl    $0x4,%rax
4005b9: 48 29 f8                sub    %rdi,%rax
4005bc: 48 89 c7                mov    %rax,%rdi
4005bf: 48 0f af ff             imul   %rdi,%rdi
4005c3: 48 8d 47 4b             lea    0x4b(%rdi),%rax
4005c7: c3                      retq
```

## Answer
```c
long switch_prob(long x, long n){
    long result = x;
    switch(n){
        case 60:
        case 62:
            // 4005a1
            result = x * 8;
            break;
        case 63:
            // 4005aa
            result = (x >> 3);
            break;
        case 64:
            // 4005b2
            result = (x << 4) - x;
            // Here, no break!
        case 65:
            // 4005bf
            x = x * x;
            // Here, no break!
        default:
            // 4005c3
            result = x + 0x4b;
    }
    return result;
}
```
# 4. Exercise 3.64
Consider the following source code, where R, S, and T are constants declared with #define:
```c
long A[R][S][T];

long store_ele(long i, long j, long k, long *dest){
    *dest = A[i][j][k];
    return sizeof(A);
}
```
In compiling this program, gcc generates the following assembly code:
```asm
store_ele:
  leaq (%rsi,%rsi,2), %rax
  leaq (%rsi,%rax,4), %rax
  movq %rdi, %rsi
  salq $6, %rsi
  addq %rsi, %rdi
  addq %rax, %rdi
  addq %rdi, %rdx
  movq A(,%rdx,8), %rax
  movq %rax, (%rcx) 
  movl $3640, %eax
  ret 
```

## A. Extend Equation3.1 from two dimensions to three to provide a formula for the location of array element $A[i][j][k]$.
* $&A[i][j][k] = x_A + 8 * (T * (i * S + j) + k)$
## B. Use your reverse engineering skills to determine the values of R, S, and T based on the assembly code.
```asm
store_ele:
  leaq (%rsi,%rsi,2), %rax // rax = 3rsi
  leaq (%rsi,%rax,4), %rax // rax = 13rsi
  movq %rdi, %rsi  // rsi = rdi
  salq $6, %rsi  // rsi = rdi << 6
  addq %rsi, %rdi // rdi = rdi + rdi << 6
  addq %rax, %rdi // rdi = 13rsi + rdi + rdi << 6
  addq %rdi, %rdx // rdx = rdx + 13rsi + rdi + rdi << 6
  movq A(,%rdx,8), %rax // rax = A + (rdx + 13rsi + rdi + rdi << 6) * 8
  movq %rax, (%rcx) 
  movl $3640, %eax
  ret 
```
rax = A + (rdx + 13rsi + rdi + rdi << 6) * 8

=> A + (k + 13j + i + i * 2^6) * 8

=> A + 8 * ((65i + 13j) +k)

=> A + 8 * (13 * (5i + j) +k)

`S`: 5
`T`: 13
`R`: 3640 / (5*13) = 56

# 5. Exercise 3.67
For this exercise, we will examine the code generated by gcc for functions that have structures as arguments and return values, and from this see how these language features are typically implemented.
The following C code has a function process having structures as argument and return values, and a function eval that calls process:
```c
typedef struct {
    long a[2];
    long *p;
} strA;

typedef struct {
    long u[2];
    long q;
} strB;

strB process(strA s){
    strB r;
    r.u[0] = s.a[1];
    r.u[1] = s.a[0];
    r.q = *s.p;
    return r;
}

long eval(long x, long y, long z) {
    strA s;
    s.a[0] = x;
    s.a[1] = y;
    s.p = &z;
    strB r = process(s);
    return r.u[0] + r.u[1] + r.q;
}
```

Gcc generates the following code for these two functions:

```asm
process:
  movq    %rdi,     %rax
  movq 24(%rsp),    %rdx
  movq   (%rdx),    %rdx
  movq 16(%rsp),    %rcx
  movq    %rcx,    (%rdi)
  movq  8(%rsp),    %rcx
  movq    %rcx,   8(%rdi)
  movq    %rdx,  16(%rdi)
  ret
```
```asm
eval:
  subq    $104,     %rsp
  movq    %rdx,  24(%rsp)
  leaq 24(%rsp),    %rax
  movq    %rdi,    (%rsp)
  movq    %rsi,   8(%rsp)
  movq    %rax,  16(%rsp)
  leaq 64(%rsp),    %rdi
  call process
  movq 72(%rsp),    %rax
  addq 64(%rsp),    %rax
  addq 80(%rsp),    %rax
  addq     $104,    %rsp
  ret
```
## A. We can see on line 2 of function eval that it allocates 104 bytes on the stack. Diagram the stack frame for eval, showing the values that it stores on the stack prior to calling process.
|--:|:--|
|<+104>||
|<+96>||
|<+88>||
|<+80>||
|<+72>||
|rdi --> <+64>||
|<+56>||
|<+48>||
|<+40>||
|<+32>||
|<+24>|z|
|<+16>|s.p|
|<+8>|s.a[1]|
|rsp --> <+0>|s.a[0]|
## B. What value does eval pass in its call to process?
* rsp + 64
  * It can be checked out from `leaq 64(%rsp),    %rdi`

## C. How does the code for process access the elements of structure argument s?
* `process` access the elements of structure by `rsp` and offset.
## D. How does the code for process set the fields of result structure r?
* `process` set the fields of result by `rdi` and offset.
## E. Complete your diagram of the stack frame for eval, showing how eval accesses the elements of structure r following the return from process.
|--:|:--|
|<+104>||
|<+96>||
|<+88>||
|<+80>|r.q|
|<+72>|r.u[1]|
|rdi --> <+64>|r.u[0]|
|<+56>||
|<+48>||
|<+40>||
|<+32>||
|<+24>|z|
|<+16>|s.p|
|<+8>|s.a[1]|
|rsp --> <+0>|s.a[0]|
* eval access `r` via `rsp`.
## F. What general principles can you discern about how structure values are passed as function arguments and how they are returned as function results?
* Caller function make space and pass address to callee function. Callee function pass return passed address from caller function. It's how to structure values are assed as function arguments and how they are returned as function results. 
# 6. Exercise 3.68
# 7. Exercise 3.70