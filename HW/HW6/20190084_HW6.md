CSED211 Homework 6
===

20190084 권민재



# 1. Exercise 10.6

What is the output of the following program?

```c
#include "csapp.h"

int main()
{
    int fd1, fd2;
    fd1 = Open("foo.txt", O_RDONLY, 0);
    fd2 = Open("bar.txt", O_RDONLY, 0);
    Close(fd2);
  	fd2 = Open("baz.txt", O_RDONLY, 0);
    printf("fd2 = %d\n", fd2);
    exit(0);
}
```



### Solution

File Descriptor (이 문서에서 이하 'FD') 0, 1, 2는 이미 할당된 상태이기 때문에, foo.txt와 bar.txt를 Open 했을 때, `fd1`, `fd2` 에는 우선 각각 FD 3, 4가 지정된다. 이후, `close(fd2)` 를 수행하고 baz.txt를 여는 시점에서 FD 4는 이미 정리되었기 때문에, baz.txt를 Open 한 FD는 4가 지정된다. 즉, fd2를 출력할 때 fd2는 4이다.

### Answer

```
fd2 = 4
```



# 2. Exercise 10.9

Consider the following invocation of the fstatcheck program from Problem 10.8:

```sh
linux> fstatcheck 3 < foo.txt
```

You might expect that this invocation of `fstatcheck` would fetch and display metadata for file `foo.txt`. However, when we run it on our system, it fails with a "bad file descriptor." Given this behavior, fill in the pseudocode that the shell must be executing between the `fork` and `execve` calls:

```c
if(Fork() == 0) { /* child */
    /* What code is the shell executing right here? */
    Execve("fstatcheck", argv, envp);
}
```



### Solution

위와 같은 동작을 수행하기 위해서는, 우선 코드 내에서 foo.txt를 열고, 해당 FD를 `dup2` 를 이용하여 STDIN으로 redirect 시킨 이후에 execve를 수행하여 fstatcheck의 input으로 들어갈 수 있도록 해야한다. 아래는 이 과정을 나타낸 답안이다.

### Answer

```c
/* csapp.h가 include된 상태로 생각하여, csapp.h에 있는 함수 정의를 이용하여 답안을 작성해야한다. (첫글자가 대문자) */
if(Fork() == 0) { /* child */
    /* What code is the shell executing right here? */
    fd = Open("foo.txt", O_RDONLY, 0);
    Dup2(fd, STDIN_FILENO);
    Close(fd);
    Execve("fstatcheck", argv, envp);
}
```

 

# 3. 

Enumerate the difference between process and thread concisely.



# 4. 

Explain the role of the following functions

## A. Getaddressinfo

## B. Socket

## C. Bind

## D. Connect

## E. Listen

## F. accept



# 5. Exercise 12.17

> Figure 12.46 Buggy program for Problem 12.17.
>
> ```c
> /* WARNING: This code is buggy! */
> 
> #include "csapp.h"
> void *thread(void *vargp);
> 
> int main()
> {
>     pthread_t tid;
>     Pthread_create(&tid, NULL, thread, NULL);
>     exit(0);
> }
> 
> /* Thread routine */
> void *thread(void *vargp)
> {
>     Sleep(1);
>     printf("Hello, world!\n");
>     return NULL;
> }
> ```

## A.

The program in Figure 12.46 has a bug. The thread is supposed to sleep for 1 second and then print a string. However, when we run it on our system, nothing prints. Why?

### Answer

 `exit` 를 이용해서 프로그램을 종료하게 되면, 프로세스의 모든 스레드가 종료되게 된다. 그런데, 메인 스레드에서 Pthread_create로 스레드를 만들자마자, `exit(0)` 을 이용하여 프로그램을 종료하기 때문에, 다른 스레드에서 `Sleep(1)` 을 마치기도 전에 모든 스레드가 종료되어 아무것도 출력되지 않는다.



## B.

You can fix this bug by replacing the `exit` function in line 10 with one of two different Pthreads function calls. Which ones?

### Answer

`exit` 대신에 `pthread_exit` 를 이용하여 종료를 하게 되면, 프로세스를 종료하기 전에 실행 중인 다른 스레드를 대기하기 때문에 `exit` 를  `pthread_exit` 로 대체해서 위 버그를 고칠 수 있다.



# 6. Exercise 12.18

Using the progress graph in Figure 12.21, classify the following trajectories as either safe or unsafe.

> **Figure 12.21.** Safe and unsafe trajectories.
>
> <img src="./figure-12-21.png" alt="image-20201216233050401" style="zoom:50%;" />

## A. 

$H_2, L_2, U_2, H_1, L_1,S_2,U_1,S_1,T_1,T_2$

**Solution.** $H_1$에서 $L_1$으로 가는 과정에서 Unsafe region에 들어가기 때문에, safe하지 않다.

**Answer.** Unsafe



## B.

$H_2, H_1, L_1, U_1, S_1, L_2, T_1, U_2, S_2, T_2$

**Solution.** 전 구간에서 Unsafe region에 들어가지 않기 때문에, 이 trajectory는 safe하다. 

**Answer.** Safe



## C.

$H_1, L_1, H_2, L_2, U_2, S_2, U_1, S_1, T_1, T_2$

**Solution.** $H_2$ 에서 $L_2$ 로 가는 과정에서 Unsafe region에 들어가기 때문에, safe하지 않다.

**Answer.** Unsafe

